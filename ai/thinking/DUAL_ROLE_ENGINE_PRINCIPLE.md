# 核心运行时设计原则：双重角色引擎

本文档记录了对 `ten-framework` 最核心、最根本的设计原则的思考。此原则是从对 `Extension` 实现进行反向推导，并聚焦于“命令驱动”和“数据驱动”这两个核心目标而得出的。

## 核心启示：引擎的双重角色

要构建一个能够支持实时对话的核心运行时，这个引擎必须完美地扮演两个既独立又协作的角色：

1.  **数据流管道 (Data-Flow Pipeline)**
2.  **异步 RPC 总线 (Async RPC Bus)**

这是从 `Extension` 的具体实现中得到的最重要的启示。

---

### 1. 作为“数据流管道”的引擎

这是对“数据驱动”的实现。

-   **`Extension` 的角色**: 在这个角色中，`Extension` 是一个**数据流转换器 (Stream Transformer)**。它消费一种或多种上游数据流，经过处理，再生产出一种或多种下游数据流。
    -   *例子*: ASR 扩展消费 `AudioFrame` 流，生产出包含文字的 `Data` 流。LLM 扩展消费包含文字的 `Data` 流，生产出包含回复文字的 `Data` 流。
-   **引擎的职责**:
    -   引擎的核心职责是一个高效的、类型安全的**消息路由器**。
    -   它提供一个 `send_data(data)` 的 API。当 `Extension` 调用此 API 时，“驱动”就发生了。
    -   引擎根据消息的目标地址，将数据包精确地投递到下一个 `Extension` 的数据处理钩子（如 `on_data`, `on_audio_frame`）。
-   **本质**: “数据驱动”的本质，就是一个允许数据在不同处理节点（`Extension`）之间，根据预定义的图拓扑高效流动的管道。

---

### 2. 作为“异步 RPC 总线”的引擎

这是对“命令驱动”的实现。

-   **`Extension` 的角色**: 在这个角色中，`Extension` 可以是**调用者 (Caller)**，也可以是**执行者 (Executor)**。
    -   *例子*: LLM 扩展作为**调用者**，发送 `tool_call` 命令。天气查询扩展作为**执行者**，接收并处理 `tool_call` 命令。
-   **引擎的职责**:
    -   引擎的核心职责是一个可靠的、支持 `Future/Promise` 模式的**异步 RPC 代理**。
    -   它提供了一套完整的异步调用契约：
        1.  **`send_cmd(cmd)`**: 调用者使用此 API 发起一个远程调用，并立即获得一个 `CompletableFuture`（或其他语言的对等体），代表未来的结果。
        2.  **`return_result(result)`**: 执行者在处理完命令后，使用此 API 将结果发送回来。
        3.  **结果关联**: 引擎负责将返回的 `result` 与其原始 `cmd` 的 `CompletableFuture` 进行匹配，并完成该 `Future`。
-   **本质**: “命令驱动”的本质，就是一个让图中任意两个节点之间，可以发起**有状态、有返回、非阻塞**的远程过程调用的通信总线。它负责处理所有异步调用的复杂性，为上层提供清晰的请求/响应模型。

---

### 结论

`ten-framework` 的灵魂，就在于这个双重角色的引擎。它将无状态、单向的数据流处理（数据驱动）和有状态、双向的控制流处理（命令驱动）优雅地统一在同一个框架之下。

我们未来所有的 Java 设计，都必须围绕着如何用 Java 的工具（`CompletableFuture`, `Flow API`, `ExecutorService` 等）来完美地实现这个**双重角色的引擎**展开。
