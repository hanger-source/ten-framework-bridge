# 迁移项目小工具清单

本文档定义了在将非 Java 项目迁移到 Java 平台过程中，指导 AI 执行任务的一系列微型、独立、指令驱动的“工具”。这些工具覆盖了从项目解构、架构设计、代码迁移到验证与重构的整个生命周期，旨在确保迁移过程的系统性、准确性和高质量。

---

## **第一部分：分析与解构 (Analysis & Deconstruction)**

### 1. 解构工具 (Deconstruction Tools)

- **`AnalyzeProjectLayout`**: 扫描 `core` 目录，生成项目文件树和统计信息（文件类型、代码行数）。
- **`ParseBuildConfiguration`**: 解析 `BUILD.gn` 文件，识别所有编译目标和模块。
- **`MapModuleDependencies`**: 根据构建配置，绘制模块间的依赖关系图。
- **`IdentifyProjectEntrypoints`**: 识别 C++/Rust 项目的主入口函数（例如 `main`）。
- **`ListSourceFileTypes`**: 统计项目中所有源代码文件的类型及其数量分布。
- **`CatalogThirdPartyLibraries`**: 识别并列出 `third_party` 目录下的所有第三方库及其版本。
- **`ExtractPublicApiFromHeaders`**: 从 C/C++ 头文件（`.h`, `.hpp`）中提取所有公开的类、函数和常量。
- **`ListClassesAndStructs`**: 列出指定 C++ 文件中的所有 `class` 和 `struct` 定义。
- **`ListFreeFunctions`**: 列出指定 C++/Rust 文件中的所有非成员函数。
- **`AnalyzeClassDetails`**: 解析 C++ 类，详尽列出其成员变量、成员函数及其可见性（public, private, protected）。
- **`FindGlobalState`**: 扫描代码库，找出所有全局变量和静态变量。
- **`CatalogMacros`**: 识别并列出所有预处理器宏定义及其用途。
- **`AnalyzeTemplatesAndGenerics`**: 分析 C++ 模板和 Rust 泛型，理解其在代码中的应用模式。
- **`TracePointerUsage`**: 查找所有裸指针、智能指针（`unique_ptr`, `shared_ptr`）的使用场景。
- **`AuditMemoryManagement`**: 检查 `new`/`delete`、`malloc`/`free` 的配对使用，分析现有内存管理模式。
- **`MapConstCorrectness`**: 分析 `const` 关键字的使用，确定数据和逻辑的不可变性。
- **`ExtractEnums`**: 列出所有的 C++ `enum` 和 `enum class` 定义。
- **`AnalyzeConcurrencyModel`**: 识别代码中的多线程实现方式（如 `std::thread`, `pthreads`）和同步原语（如 `std::mutex`）。
- **`MapExceptionHandling`**: 查找 `try`/`catch` 块和错误码返回，分析现有错误处理流程。
- **`DeconstructRustCrates`**: 解析 `Cargo.toml` 和 `*.rs` 文件，识别 Rust Crate 的结构、模块和公共 API。
- **`IdentifyFFIBoundaries`**: 识别 C++/Rust 与其他语言（特别是 C）的外部函数接口（FFI）。
- **`TraceFunctionCallGraph`**: 为指定核心功能追踪并绘制函数调用图。
- **`ListOperatorOverloads`**: 找出所有被重载的 C++ 操作符。
- **`AnalyzeDataSerialization`**: 检查项目中用于数据序列化/反序列化的机制（如 JSON, Protobuf, or custom formats）。
- **`IdentifySystemAPIs`**: 列出项目中对操作系统特定 API 的调用。
- **`AnalyzeFileSystemInteractions`**: 查找所有文件 I/O 操作，了解其如何与文件系统交互。
- **`AnalyzeNetworkInteractions`**: 查找所有网络编程相关的代码（sockets, HTTP calls）。
- **`EvaluateCodeComplexity`**: 对关键函数和模块进行圈复杂度分析。
- **`IdentifyBitwiseOperations`**: 列出所有位操作，理解其在性能优化或数据打包中的作用。
- **`ParseConfigurationFiles`**: 检查项目使用的配置文件格式和读取逻辑。

### 2. 评估工具 (Evaluation Tools)

- **`AssessMigrationFeasibility`**: 评估特定模块迁移到 Java 的可行性和复杂度。
- **`EvaluateThirdPartyLibraryEquivalents`**: 为每个 C++/Rust 第三方库寻找并评估功能对等的 Java 库。
- **`BenchmarkPerformanceCriticalCode`**: 识别并度量性能关键路径的当前表现。
- **`EstimateMigrationEffort`**: 估算迁移每个模块所需的工作量。
- **`QuantifyApiSurface`**: 量化需要被迁移和重新设计的公共 API 数量。
- **`ScoreCodeReadability`**: 对原始代码的可读性进行评分，以预估理解成本。
- **`AnalyzeCodeCoupling`**: 分析模块间的耦合度，识别重构机会。
- **`CheckCrossPlatformCompatibility`**: 评估原始代码的可移植性，识别平台依赖。
- **`EvaluateBuildSystemComplexity`**: 评估现有构建系统的复杂度及其对迁移的影响。
- **`AssessTestCoverage`**: 评估现有测试用例的覆盖率，判断可用于验证迁移的程度。
- **`ReviewExistingDocumentation`**: 审查现有文档的质量和完整性。
- **`IdentifySecurityRisks`**: 评估原始代码中潜在的安全漏洞（如缓冲区溢出）。
- **`CompareLanguageParadigms`**: 比较 C++/Rust 和 Java 在核心模块中的编程范式差异。
- **`EvaluateDataModelComplexity`**: 评估核心数据结构的复杂性。
- **`JudgeMaintainability`**: 对原始代码库的可维护性进行打分。

### 3. 搜索工具 (Search Tools)

- **`FindAllUsagesOfFunction`**: 在代码库中查找指定函数的所有调用位置。
- **`FindAllImplementationsOfClass`**: 查找一个基类的所有派生类。
- **`GrepForPattern`**: 在代码库中执行基于正则表达式的文本搜索。
- **`LocateFileByName`**: 根据文件名模糊或精确查找文件。
- **`SearchForMagicNumbers`**: 查找代码中未命名的硬编码常量。
- **`FindCodeWithoutTests`**: 搜索没有对应单元测试的生产代码文件或类。
- **`QueryCodeByStructure`**: (概念) 使用代码结构查询语言（如 Semgrep）来查找特定代码模式。
- **`SearchForTodoComments`**: 查找代码中所有的 `TODO`, `FIXME` 等注释。
- **`FindDirectMemoryAccess`**: 搜索直接访问硬件或内存地址的代码。
- **`LocateStringLiterals`**: 查找并列出代码中所有的字符串字面量，用于国际化分析。

## **第二部分：设计与规划 (Design & Planning)**

### 4. 抽象工具 (Abstraction Tools)

- **`DesignJavaPackageStructure`**: 基于原始模块，设计目标 Java 项目的包（package）结构。
- **`DefineJavaClassInterfaces`**: 为每个待迁移的 C++ 类或 Rust 结构体设计对应的 Java 类或接口。
- **`ProposeDesignPatterns`**: 针对特定问题，建议使用合适的 GoF 设计模式（如工厂、策略、观察者等）。
- **`AbstractPlatformDependencies`**: 设计接口以封装所有平台相关的代码，便于未来扩展。
- **`CreateDataTransferObjects`**: 为跨进程或跨网络通信设计 DTO。
- **`ModelConfigurationHandling`**: 设计一套灵活的 Java 配置管理机制。
- **`DesignErrorHandlingStrategy`**: 定义 Java 项目的统一异常处理策略和自定义异常类。
- **`ArchitectConcurrencyStrategy`**: 设计 Java 中的并发模型，选择合适的 `java.util.concurrent` 工具。
- **`DefineLoggingFramework`**: 选择并设计日志框架（如 SLF4J + Logback）的集成方案。
- **`ModelImmutableDataStructures`**: 将 C++ 的 `const` 或 Rust 的不可变性概念映射到 Java 的不可变对象或 record。
- **`DesignDependencyInjection`**: 设计依赖注入方案（如使用 Spring, Guice 或手动注入）。
- **`PlanTestingStrategy`**: 规划单元测试、集成测试和端到端测试的策略。
- **`DraftApiForNewModules`**: 为新功能或重构后的模块起草新的 API。
- **`SpecifyServiceBoundaries`**: 在微服务架构中，定义服务间的边界和通信协议。
- **`FactorOutUtilityClasses`**: 将通用的辅助函数重构为静态工具类。

### 5. 命名工具 (Naming Tools)

- **`GenerateJavaClassName`**: 根据 C++ 类名和 Java 规范生成 Java 类名。
- **`GenerateJavaMethodName`**: 根据 C++/Rust 函数名生成符合 Java 风格的方法名。
- **`GenerateJavaVariableName`**: 为变量生成符合 Java 风格的名称。
- **`GeneratePackageName`**: 根据模块功能和公司域生成包名。
- **`ProposeEnumConstantNames`**: 将 C++ 枚举成员转换为 Java 枚举常量名称。
- **`StandardizeAcronymsInNames`**: 统一命名中缩写词的大小写（例如 `Http` vs `HTTP`）。
- **`SuggestAlternativeNames`**: 为模糊不清的名称提供更具描述性的备选方案。
- **`CheckNameCollisions`**: 检查新命名是否与 Java 标准库或依赖库冲突。
- **`TranslateToEnglish`**: 将非英文的标识符翻译成标准的英文名称。
- **`ApplyProjectNamingConventions`**: 确保所有新命名都遵循项目既定的命名规范。

### 6. 约束工具 (Constraint Tools)

- **`DefineCodingStandard`**: 设定项目的 Java 编码规范（如 Google Java Style Guide）。
- **`SetupLinterAndStaticAnalysis`**: 配置 Checkstyle, PMD, SpotBugs 等静态分析工具并定义规则集。
- **`RestrictApiAccess`**: 使用 Java 的访问修饰符（`private`, `protected`, package-private）来约束 API 的可见性。
- **`EnforceImmutability`**: 设立规则，要求在适当的情况下优先使用不可变对象。
- **`DefineAllowedDependencies`**: 定义一份项目允许使用的第三方库白名单。
- **`SetPerformanceBudgets`**: 为关键业务逻辑设定性能预算（如响应时间、内存占用）。
- **`MandateTestCoverageThreshold`**: 设定单元测试必须达到的最低代码覆盖率。
- **`ProhibitDeprecatedApiUsage`**: 禁止使用 JDK 或第三方库中已废弃的 API。
- **`SpecifyJavaVersion`**: 明确项目使用的 Java 版本（如 LTS 11, 17）。
- **`DefineBuildEnvironment`**: 约束构建和部署所需的环境（JDK, Maven/Gradle 版本）。
- **`LimitResourceUsage`**: 为资源密集型操作设定资源使用上限（如线程池大小）。
- **`EnforceInterfaceUsage`**：要求模块间通信必须通过接口，而非具体实现。

## **第三部分：实施与验证 (Implementation & Verification)**

### 7. 执行工具 (Execution Tools)

- **`CreateProjectScaffold`**: 使用 Maven 或 Gradle 创建新的 Java 项目骨架。
- **`AddDependencyToBuildFile`**: 将一个新的库依赖添加到 `pom.xml` 或 `build.gradle`。
- **`TranslateFile`**: 将一个 C++/Rust 源文件逐行、逐逻辑地翻译成 Java 文件。
- **`ImplementClass`**: 在 Java 中实现一个类的骨架。
- **`ImplementMethod`**: 在 Java 中实现一个具体方法的逻辑。
- **`WriteUnitTest`**: 为一个 Java 类或方法编写 JUnit/TestNG 测试。
- **`WriteIntegrationTest`**: 编写测试来验证多个组件的协同工作。
- **`RefactorToPattern`**: 将现有代码重构成指定的设计模式。
- **`ExtractInterface`**: 从一个具体类中提取出一个接口。
- **`ReplaceMacroWithJavaEquivalent`**: 将 C++ 宏替换为 Java 的常量、枚举或函数。
- **`ReplacePointerWithReference`**: 将指针逻辑替换为 Java 的对象引用和垃圾回收机制。
- **`ConvertBuildScripts`**: 将 `BUILD.gn` 中的逻辑迁移到 Maven/Gradle 构建脚本中。
- **`SetupCI-CD-Pipeline`**: 建立持续集成和持续部署的流水线。
- **`MigrateData`**: 编写脚本迁移旧系统持久化的数据到新系统。
- **`DocumentCode`**: 为公共 API 编写 Javadoc 注释。
- **`ApplyCodeFormatting`**: 应用统一的代码格式化。

### 8. 验证工具 (Validation Tools)

- **`CompileProject`**: 编译整个 Java 项目，检查编译错误。
- **`RunUnitTests`**: 执行所有单元测试并报告结果。
- **`RunIntegrationTests`**: 执行所有集成测试。
- **`RunStaticAnalysis`**: 运行静态代码分析工具并报告违规项。
- **`PerformPeerReviewSimulation`**: 模拟代码审查过程，检查可读性、设计和规范遵守情况。
- **`ConductSemanticEquivalenceTest`**: 通过给定相同输入，对比新旧系统输出来验证逻辑等价性。
- **`ProfileMemoryUsage`**: 使用 JProfiler, VisualVM 等工具分析 Java 应用的内存占用。
- **`ProfileCpuPerformance`**: 分析 CPU 使用情况，找出性能瓶颈。
- **`CheckApiCompatibility`**: 验证迁移后的 API 是否与原始 API 向后兼容。
- **`ValidateConfiguration`**: 检查配置文件是否能被正确加载和解析。
- **`TestErrorHandling`**: 模拟各种错误场景，验证异常处理流程是否符合设计。
- **`VerifyConcurrencySafety`**: 通过压力测试和代码分析验证线程安全性。
- **`CheckLogOutput`**: 检查日志输出是否符合预期，包含足够的信息。
- **`TestBoundaryConditions`**: 专门测试各种边界情况（如 null 输入，空集合，最大/最小值）。
- **`EnsureBuildReproducibility`**: 验证在不同环境中构建的结果是否一致。

### 9. 效率工具 (Efficiency Tools)

- **`AutomateCodeGeneration`**: 根据数据模型自动生成部分样板代码（如 DTOs, mappers）。
- **`CreateCodeSnippets`**: 为常用的代码模式创建可复用的代码片段。
- **`BatchApplyRefactoring`**: 在整个代码库中批量执行简单的重构（如方法重命名）。
- **`ParallelizeMigrationTasks`**: 识别并并行执行无依赖关系的迁移任务。
- **`CacheBuildArtifacts`**: 配置构建系统以缓存依赖和编译输出，加快构建速度。
- **`UseLiveReloading`**: 在开发环境中配置实时重新加载，以快速查看变更效果。
- **`IntegrateWithIDE`**: 确保项目结构能被主流 IDE (IntelliJ, Eclipse, VSCode) 正确识别和支持。
- **`GenerateDocumentationWebsite`**: 从 Javadoc 自动生成可浏览的 API 文档网站。
- **`ScriptRoutineTasks`**: 将重复性任务（如清理、打包、部署）脚本化。
- **`QuickNavigateToDefinition`**: 提供快速从代码使用处跳转到定义处的功能。

## **第四部分：元认知与协同 (Meta-cognition & Collaboration)**

### 10. 解释工具 (Explanation Tools)

- **`ExplainMigrationChoice`**: 解释为什么选择特定的 Java 库或设计模式。
- **`DescribeCodeFunctionality`**: 用自然语言描述一段代码的功能和逻辑。
- **`ClarifyTechnicalConcept`**: 解释一个技术术语或概念（如 "RAII", "garbage collection"）。
- **`SummarizeFileContent`**: 总结一个源文件的主要职责和内容。
- **`JustifyRefactoring`**: 解释进行某项重构的原因和预期收益。
- **`DocumentArchitecturalDecision`**: 记录一项重要的架构决策及其背后的权衡。
- **`ExplainDifferenceBetweenVersions`**: 解释两个代码版本之间的主要差异。
- **`GenerateChangeLog`**: 根据提交历史自动生成版本变更日志。
- **`TranslateErrorMessage`**: 将技术性的错误信息翻译成易于理解的描述。
- **`AnnotateLegacyCode`**: 在理解旧代码时添加注释，说明其行为和意图。

### 11. 历史工具 (History Tools)

- **`LogDecision`**: 记录下迁移过程中的每一个重要决策。
- **`TrackMigrationProgress`**: 跟踪每个模块的迁移状态（未开始,进行中,已完成）。
- **`GetFileRevisionHistory`**: 查看一个文件在版本控制系统中的变更历史。
- **`CompareCodeSnapshots`**：比较项目在不同时间点的代码快照。
- **`RevertChange`**: 撤销一次或多次代码变更。
- **`CorrelateCommitToTask`**: 将代码提交关联到具体的迁移任务。
- **`ArchiveObsoleteCode`**: 将已迁移或废弃的旧代码归档，而不是直接删除。
- **`ReviewPastDecisions`**: 回顾过去的决策，评估其当前是否依然有效。
- **`CreateMigrationTimeline`**: 创建一个可视化的时间线，展示迁移的关键里程碑。
- **`SnapshotDependencies`**: 在关键节点为项目的依赖库创建快照。

### 12. 任务驱动工具 (Task-Driven Tools)

- **`CreateTask`**: 定义一个新的迁移任务。
- **`DecomposeTask`**: 将一个大任务分解成多个可执行的子任务。
- **`PrioritizeTasks`**: 根据依赖关系和重要性对任务进行排序。
- **`AssignTask`**: (在多AI或人机协作中) 将任务分配给某个执行者。
- **`UpdateTaskStatus`**: 更新任务的状态（pending, in_progress, completed, blocked）。
- **`LinkTasks`**: 建立任务之间的依赖关系。
- **`QueryTasksByStatus`**: 按状态查询任务列表。
- **`EstimateTaskDuration`**: 估算完成一个任务所需的时间。
- **`GenerateProgressReport`**: 基于任务完成情况生成进度报告。
- **`DefineMilestone`**: 定义一个代表项目重要进展的里程碑。

### 13. 反思工具 (Reflection Tools)

- **`ReviewCompletedTask`**: 在任务完成后进行复盘，总结经验教训。
- **`AskClarifyingQuestions`**: 当指令不明确时，向用户提出问题以澄清意图。
- **`SelfCorrect`**: 在发现错误后，自动进行修正。
- **`IdentifyKnowledgeGaps`**: 识别出自身知识库中存在的不足，并提出学习建议。
- **`ProposeAlternativeSolutions`**: 针对一个问题提出多种可能的解决方案并进行比较。
- **`ReflectOnCodeQuality`**: 对刚刚生成的代码质量进行自我评估。
- **`EvaluateToolEffectiveness`**: 评估某个“小工具”在实践中的效果。
- **`ThinkStepByStep`**: 在执行复杂任务前，先输出详细的思考步骤。
- **`ConsiderEdgeCases`**: 主动思考并提出需要处理的边缘情况。
- **`PauseAndConfirm`**: 在执行关键性或破坏性操作前，暂停并请求用户确认。

### 14. 组合工具 (Composition Tools)

- **`ChainCommands`**: 将多个小工具串联起来，形成一个自动化的工作流。
- **`ComposeMigrationPlan`**: 组合使用分析、评估和任务规划工具，生成完整的迁移计划。
- **`BuildVerificationSuite`**: 组合多种验证工具，构建一个全面的代码质量保证套件。
- **`GenerateFullClass`**: 组合命名、实现、文档和测试工具，完整地生成一个 Java 类。
- **`ExecuteEndToEndScenario`**: 组合多个执行和验证工具，执行一个端到端的业务场景。

## 第五部分：生态与集成 (Ecosystem & Integration)

### 15. 生态对齐工具 (Ecosystem Alignment Tools)

- **`AdoptLoggingFacade`**: 将项目中分散的日志记录方式统一替换为 SLF4J 门面，并配置具体的日志实现（如 Logback）。
- **`IntegrateBuildLifecycle`**: 确保项目遵循 Maven/Gradle 的标准目录布局和构建生命周期。
- **`IntroduceDependencyInjection`**: 使用 Guice 或 Spring 等 DI 框架来管理组件的生命周期和依赖关系，替代手动创建对象。
- **`ExposeMetrics`**: 集成 Micrometer，将关键业务和性能指标通过 JMX 或 HTTP 端点暴露给 Prometheus 等监控系统。
- **`StandardizeConfiguration`**: 采用 HOCON (via Typesafe Config) 或 Spring Configuration 等标准库来管理应用配置，替代自定义解析。
- **`MapToAdvancedConcurrency`**: 将底层的线程和锁操作，映射为 Java `java.util.concurrent` 包中更高级的抽象，如 `ExecutorService`, `CompletableFuture`, `StampedLock` 等。
- **`UseStandardDataBinding`**: 对所有外部数据（如 JSON, XML），使用 Jackson 等库进行标准化的数据绑定，替代手动解析。
- **`ImplementHealthChecks`**: 实现标准化的健康检查端点，便于服务发现和自动化运维。
- **`FollowApiBestPractices`**: 确保公共 API 设计遵循 Java 社区的最佳实践，例如返回 `Optional` 而不是 `null`，使用标准的集合接口等。
- **`AlignExceptionHierarchy`**: 构建一套继承自 Java 标准异常类的、层次清晰的自定义异常体系。

### 16. 开源方案融合工具 (Open Source Integration Tools)

- **`BuildOnNetty`**: 围绕 Netty 的核心组件（如 `ChannelPipeline`, `EventLoopGroup`）来重构网络层，而不是简单地调用其 API。
- **`AbstractViaSPI`**: 对序列化、配置、插件加载等核心功能，设计服务提供者接口 (SPI)，并为 Jackson, Typesafe Config 等具体库提供适配器实现。
- **`WrapWithAdapter`**: 对专门的库（如 `JavaCV`, `OptaPlanner`），设计一个简化的、符合项目领域模型的适配器层，以隔离复杂性并统一接口。
- **`EmbraceReactiveStreams`**: 在适当的数据流场景，引入 Reactive Streams 规范（如使用 `Project Reactor` 或 `RxJava`），以更好地处理背压和异步数据流。
- **`LeverageGraalVMNative`**: 在性能关键路径，探索使用 GraalVM Native Image 技术将部分 Java 代码编译为本地可执行文件，以获得极致性能。
- **`IntegrateDIContainerLifecycle`**: 将 App, Engine 等核心组件的生命周期交由依赖注入容器（如 Guice, Spring）管理。

---

_这份清单是动态的，在迁移过程中可以根据实际需要随时进行更新和完善。_

## 第六部分：战略与意图 (Strategy & Intent)

### 17. 目标任务识别工具 (Goal & Task Identification Tools)

- **`DecomposeFinalGoal`**: 将最终目的（如“具备开源质量的 Java 项目”）分解为一系列可衡量的、具体的顶层目标（如“API 稳定性”、“详尽的文档”、“高测试覆盖率”）。
- **`MapTasksToGoals`**: 将每一个具体的实施任务（如“实现 `Connection` 类”）关联到一个或多个顶层目标，确保每个任务都在为最终目的服务。
- **`IdentifySuccessMetrics`**: 为每个顶层目标定义明确的成功标准（例如，“测试覆盖率 > 85%”，“API 核心类 Javadoc 100% 覆盖”）。
- **`PrioritizeByBusinessValue`**: 根据任务对核心痛点的解决程度或对商业价值的贡献度，对其进行优先级排序。

### 18. 目标深化提问工具 (Goal Deepening & Questioning Tools)

- **`AskWhy`**: 针对每一个顶层目标，反复提问“为什么这个很重要？”，直到触及最根本的业务或技术驱动力。
- **`IdentifyTargetAudience`**: 明确新项目的最终用户是谁（内部开发者？外部社区？），并以此为依据调整设计决策。
- **`ExploreFutureEvolution`**: 提问关于项目长期演进方向的问题，以确保当前架构具有足够的前瞻性和可扩展性。
- **`ClarifyNonFunctionalRequirements`**: 主动询问关于性能、安全性、可靠性、可维护性等非功能性需求的具体指标。
- **`ChallengeAssumptions`**: 对迁移过程中的固有假设（例如“必须100%对等迁移”）提出质疑，探索更优或更符合 Java 习惯的实现路径。
