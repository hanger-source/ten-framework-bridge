# 核心迁移点重新梳理

## 1. 重新理解系统架构

### 1.1 实际的数据流分析

```
用户操作 → 前端 (playground)
  ↓ 调用 /api/token/generate
Java Server (addons/server) → 生成 token
  ↓ 返回 token
前端 (playground) → 使用 token 连接 RTC
  ↓ 音视频通信
RTC 服务 (Agora/阿里云)
```

### 1.2 完整的系统架构

**重要发现**: 通过深入分析，发现系统实际上是一个复杂的微服务架构：

```
前端 (playground)
    ↓ HTTP请求
中间件 (middleware.tsx)
    ↓ URL重写
Java后端 (addons/server)
    ↓ 启动Worker
Go Worker进程 (agents/bin/start)
    ↓ 加载扩展
RTC扩展 (agora_rtc/agora_rtm)
    ↓ 连接服务
RTC服务 (Agora/阿里云)
```

**关键组件**:

1. **前端层**: Next.js应用，负责UI和用户交互
2. **中间件层**: 处理API请求路由和重写
3. **后端层**: Java Spring Boot应用，负责Token生成和Worker管理
4. **Worker层**: Go进程，负责具体的RTC连接和消息处理
5. **扩展层**: 各种扩展模块，包括RTC、RTM、LLM等
6. **服务层**: 外部RTC服务提供商

**数据流向**:

1. **Token生成**: 前端 → 中间件 → Java后端 → 返回Token
2. **Worker启动**: Java后端 → 启动Go Worker进程
3. **RTC连接**: Go Worker → 加载RTC扩展 → 连接RTC服务
4. **消息传递**: RTC扩展 → 处理音视频和消息 → 返回给前端

### 1.3 Worker 的真实作用

- Worker 只是接收 `properties` 参数
- `properties` 中包含 RTC 相关信息
- Worker 本身不直接处理 RTC 连接
- Worker 只是被传递配置，不是核心迁移点

## 2. 真正的核心迁移点

### 2.1 后端 Token 生成服务

**位置**: `ai_agents/addons/server/src/main/java/com/agora/tenframework/service/TokenService.java`

**核心功能**:

- 生成 Agora RTC Token
- 需要迁移为支持阿里云 RTC Token 生成

**关键差异**:

- Agora: 使用 `RtcTokenBuilder2`，需要 `appId`, `appCertificate`
- 阿里云: 使用 `@dingrtc/token-generator`，需要 `appId`, `appKey`

**具体迁移点**:

- Token生成器: `RtcTokenBuilder2.buildTokenWithUid()` → 阿里云Token生成器
- 参数配置: `appCertificate` → `appKey`
- Token格式: 需要保持兼容性，确保前端能正确解析

### 2.2 前端 RTC 客户端

**位置**: `ai_agents/playground/src/manager/rtc/rtc.ts`

**核心功能**:

- 使用 Agora RTC SDK 连接音视频
- 需要迁移为使用阿里云 RTC SDK

**关键差异**:

- Agora: `agora-rtc-sdk-ng`
- 阿里云: `dingrtc`

**具体迁移点**:

- 客户端创建: `AgoraRTC.createClient({ mode: "rtc", codec: "vp8" })` → `DingRTC.createClient()`
- 轨道创建:
  - `AgoraRTC.createCameraVideoTrack()` → `client.createCameraVideoTrack()`
  - `AgoraRTC.createMicrophoneAudioTrack()` → `client.createMicrophoneAudioTrack()`
  - `AgoraRTC.createScreenVideoTrack()` → `client.createScreenVideoTrack()`
- 房间加入: `client.join(appId, channel, token, uid)` → `client.join({appId, token, uid, channel, userName})`
- 类型定义: `IAgoraRTCClient` → `DingRTCClient`
- 事件监听:
  - `client.on("user-published")` → 阿里云对应的事件
  - `client.on("user-unpublished")` → 阿里云对应的事件
  - `client.on("stream-message")` → 阿里云对应的事件
- 轨道管理:
  - `client.publish(tracks)` → 阿里云对应的发布方式
  - `client.unpublish(track)` → 阿里云对应的取消发布方式
  - `client.subscribe(user, mediaType)` → 阿里云对应的订阅方式

### 2.3 前端 RTM 消息传递

**位置**: `ai_agents/playground/src/manager/rtm/index.ts`

**核心功能**:

- 使用 Agora RTM SDK 传递AI和用户消息流
- 处理流式文本消息和二进制消息
- 支持消息分片和重组

**关键发现**:

- **双通道架构**: Agora使用RTC + RTM双通道
  - RTC: 负责音视频传输
  - RTM: 负责消息传递（AI流式输出、用户输入等）
- **消息类型**: 支持STRING和BINARY两种消息类型
- **流式处理**: 支持消息分片，处理大消息的流式传输
- **事件监听**: 监听message和presence事件
- **消息格式**: 使用JSON格式，包含is_final、ts、text、type、stream_id等字段
- **自定义类型**: 支持customType字段，当前使用"PainTxt"

**具体迁移点**:

- RTM客户端创建: `new AgoraRTM.RTM(appId, String(userId))` → `new RTM()`
- 用户登录: `rtm.login({ token })` → 阿里云RTM对应的登录方式
- 频道订阅: `rtm.subscribe(channel, options)` → 阿里云RTM对应的订阅方式
- 消息发布: `rtm.publish(channel, message, { customType })` → 阿里云RTM对应的发布方式
- 事件监听: `addEventListener("message")` → 阿里云RTM对应的事件监听
- 消息处理: 需要保持JSON格式和字段结构不变

### 2.4 前端 Token 获取

**位置**: `ai_agents/playground/src/common/request.ts`

**核心功能**:

- 调用 `/api/token/generate` 获取 token
- 需要支持指定 RTC 类型

### 2.5 前端 RTM 管理器

**位置**: `ai_agents/playground/src/manager/rtm/index.ts`

**核心功能**:

- 使用 Agora RTM SDK 管理消息传递
- 处理 STRING 和 BINARY 两种消息类型
- 支持消息订阅、发布和事件监听
- 处理用户输入消息和AI流式输出

**关键发现**:

- **消息类型**: 支持 STRING 和 BINARY 两种类型
- **消息格式**: 使用 JSON 格式传递消息内容
- **事件监听**: 监听 message 和 presence 事件
- **消息发布**: 支持自定义消息类型 (customType: "PainTxt")

**具体迁移点**:

- RTM客户端创建: `new AgoraRTM.RTM(appId, String(userId))` → `new RTM()`
- 频道订阅: `rtm.subscribe(channel, options)` → 阿里云RTM对应的订阅方式
- 消息发布: `rtm.publish(channel, message, options)` → 阿里云RTM对应的发布方式
- 事件监听: `addEventListener("message")` → 阿里云RTM对应的事件监听

## 3. 非核心迁移点

### 3.1 Worker 配置传递

- 只是传递 `properties` 参数
- 不需要深入修改 Worker 内部逻辑
- 只需要在启动时传递 RTC 类型信息

### 3.2 Worker 属性映射

**重要发现**: 通过分析 `ai_agents/server/internal/config.go`，发现Worker属性映射机制：

```go
// 属性映射配置
startPropMap = map[string][]Prop{
    "ChannelName": {
        {ExtensionName: extensionNameAgoraRTC, Property: "channel"},
        {ExtensionName: extensionNameAgoraRTM, Property: "channel"},
    },
    "Token": {
        {ExtensionName: extensionNameAgoraRTC, Property: "token"},
        {ExtensionName: extensionNameAgoraRTM, Property: "token"},
    },
}
```

**迁移点**:

- **扩展属性映射**: 需要添加阿里云RTC的扩展名映射
- **保持映射结构**: 现有的映射机制保持不变
- **新增扩展名**: 需要定义 `extensionNameAliRTC` 和 `extensionNameAliRTM`
- **Token映射**: 阿里云RTC和RTM都需要Token映射

### 3.3 Worker 启动参数

**重要发现**: Worker启动时通过命令行参数传递配置：

```java
// 当前Worker启动命令
command.add(WORKER_EXEC);
command.add("--channel");
command.add(worker.getChannelName());
command.add("--port");
command.add(String.valueOf(worker.getHttpServerPort()));
```

**迁移点**:

- **添加RTC类型参数**: 需要传递 `--rtc-type` 参数
- **保持现有参数**: 现有的 `--channel` 和 `--port` 参数不变
- **后端适配**: Worker进程需要支持解析 `--rtc-type` 参数

### 3.4 中间件转发

- 只是简单的 URL 重写
- 不需要修改

### 3.5 其他组件

- 大部分 UI 组件不需要修改
- 只需要修改 RTC 相关的核心逻辑

## 4. 关键发现：双通道架构

### 4.1 Agora 双通道架构

```
Agora RTC SDK (音视频传输)
    ↓
Agora RTM SDK (消息传递)
    ↓
AI流式输出 + 用户输入
```

**RTC通道**:

- 负责音视频传输
- 使用 `agora-rtc-sdk-ng`
- 处理摄像头、麦克风、屏幕共享等
- 支持 `stream-message` 事件，用于传递二进制数据

**RTM通道**:

- 负责消息传递
- 使用 `agora-rtm`
- 处理AI流式文本输出、用户输入消息等
- 支持 STRING 和 BINARY 两种消息类型
- 支持自定义消息类型 (customType: "PainTxt")

### 4.2 阿里云RTM方案

**重要发现**: 根据[阿里云RTM官方文档](https://help.aliyun.com/document_detail/2879041.html)，阿里云RTC**完全支持RTM功能**！

**阿里云RTM功能**:

1. **完整的RTM支持**:
   - 实时消息传递（低延时、高并发、高可靠性）
   - 广播消息和点对点消息
   - 会话（Session）管理
   - 与DingRTC SDK配合使用

2. **两种集成方式**:
   - **独立使用**: 只使用RTM功能
   - **配合DingRTC使用**: 与DingRTC实例共享频道链接

3. **核心API**:

   ```typescript
   // 创建RTM实例
   import RTM from "@dingrtc/rtm";
   const rtm = new RTM();

   // 加入频道
   await rtm.join({
     appId: "",
     userName: "",
     channel: "",
     uid: "",
     token: "",
   });

   // 发布消息
   rtm.publish(sessionId, encoder.encode(message));

   // 监听消息
   rtm.on("message", (data) => {
     console.log(data);
   });
   ```

### 4.3 迁移策略

1. **推荐方案**: 阿里云RTC + 阿里云RTM
   - 保持双通道架构
   - RTC通道: 阿里云RTC负责音视频
   - RTM通道: 阿里云RTM负责消息传递

2. **实施步骤**:
   - 第一步: 迁移RTC音视频功能
   - 第二步: 迁移RTM消息传递功能
   - 第三步: 集成双通道功能

3. **技术架构**:

```
阿里云RTC (音视频传输)
    ↓
阿里云RTM (消息传递)
    ↓
AI流式输出 + 用户输入
```

## 5. 新增发现：数据通道功能

### 5.1 RTC 数据通道

**重要发现**: 在 `ai_agents/playground/src/manager/rtc/rtc.ts` 中发现 RTC 客户端还支持数据通道功能：

- **stream-message 事件**: 用于接收二进制数据流
- **消息分片处理**: 支持大消息的分片传输和重组
- **TextDataChunk 结构**: 包含 message_id、part_index、total_parts、content 字段
- **消息缓存机制**: 使用 messageCache 缓存分片消息
- **超时处理**: 5秒超时机制处理不完整消息

## 6. 新增发现：API请求架构

### 6.1 前端API请求流程

**重要发现**: 通过分析 `ai_agents/playground/src/common/request.ts` 和 `ai_agents/playground/src/middleware.tsx`，发现API请求的完整流程：

```
前端请求 → middleware.tsx → AGENT_SERVER_URL → 后端服务
```

**具体流程**:

1. **前端发起请求**: `apiGenAgoraData()` 调用 `/api/token/generate`
2. **中间件拦截**: `middleware.tsx` 拦截 `/api/token/` 请求
3. **URL重写**: 将请求重写到 `${AGENT_SERVER_URL}/token/generate`
4. **后端处理**: 后端服务处理Token生成请求

### 6.2 API请求架构迁移点

**具体迁移点**:

- **保持URL结构**: `/api/token/generate` 保持不变
- **扩展请求参数**: 添加 `rtcType` 参数支持双RTC
- **保持中间件逻辑**: `middleware.tsx` 的重写逻辑不变
- **后端适配**: 后端需要支持 `rtcType` 参数处理

### 6.3 统一的API接口设计

**建议的API接口**:

```typescript
// 统一的Token生成接口
interface GenRtcDataConfig {
  userId: string | number;
  channel: string;
  rtcType?: string; // 新增字段，支持 "agora" | "ali"
}

export const apiGenRtcData = async (config: GenRtcDataConfig) => {
  const url = `/api/token/generate`;
  const { userId, channel, rtcType = "agora" } = config;
  const data = {
    request_id: genUUID(),
    uid: userId,
    channel_name: channel,
  };

  // 添加RTC类型参数
  const params = new URLSearchParams({ rtcType });
  let resp: any = await axios.post(`${url}?${params}`, data);
  resp = resp.data || {};
  return resp;
};

// 保持向后兼容
export const apiGenAgoraData = async (config: GenAgoraDataConfig) => {
  return apiGenRtcData({ ...config, rtcType: "agora" });
};
```

### 5.2 数据通道迁移点

**具体迁移点**:

- 数据通道事件: `client.on("stream-message")` → 阿里云RTC对应的数据通道事件
- 消息解析: `new TextDecoder("utf-8").decode(data)` → 保持相同的解码方式
- 分片处理: 需要保持 TextDataChunk 结构和处理逻辑
- 消息重组: `reconstructMessage()` 方法需要保持兼容性
- 事件发射: `this.emit("textChanged", textItem)` → 保持事件发射机制

### 5.3 数据通道消息格式

**重要发现**: 数据通道处理的消息格式包含以下字段：

```typescript
interface TextDataChunk {
  message_id: string; // 消息ID，用于分片重组
  part_index: number; // 分片索引
  total_parts: number; // 总分片数
  content: string; // 分片内容
}
```

**消息处理流程**:

1. **接收分片**: 通过 `stream-message` 事件接收二进制数据
2. **解码数据**: 使用 `TextDecoder` 解码为字符串
3. **解析分片**: 按 `|` 分隔符解析出 message_id、part_index、total_parts、content
4. **缓存分片**: 使用 messageCache 缓存分片数据
5. **重组消息**: 当所有分片接收完成时，按 part_index 排序重组
6. **解析消息**: 使用 `atob()` 解码 base64 编码的完整消息
7. **处理消息**: 解析 JSON 格式的消息内容，包含 stream_id、is_final、text、text_ts、data_type 等字段
8. **发射事件**: 通过 `textChanged` 事件发射处理后的消息

**迁移注意事项**:

- 需要保持消息格式和字段结构不变
- 需要保持分片处理逻辑不变
- 需要保持事件发射机制不变
- 需要确保阿里云RTC支持相同的数据通道功能

4. **API迁移对比**:
   - Agora RTM: `new AgoraRTM.RTM()` → 阿里云RTM: `new RTM()`
   - Agora RTM: `rtm.publish()` → 阿里云RTM: `rtm.publish()`
   - Agora RTM: `rtm.on('message')` → 阿里云RTM: `rtm.on('message')`

### 4.4 平滑过渡策略

#### 4.4.1 连接管理平滑过渡

**Agora RTC连接流程**:

```typescript
// 1. 创建客户端
const client = AgoraRTC.createClient({ mode: "rtc", codec: "vp8" });

// 2. 加入房间
await client.join(appId, channel, token, uid);

// 3. 监听连接状态
client.on("connection-state-change", (curState, prevState) => {
  console.log("连接状态变化:", prevState, "->", curState);
});
```

**阿里云RTC连接流程**:

```typescript
// 1. 创建客户端
const client = DingRTC.createClient();

// 2. 加入房间
await client.join({
  appId: appId,
  token: token,
  uid: uid,
  channel: channel,
  userName: userName,
});

// 3. 监听连接状态
client.on("connection-state-change", (curState, prevState, reason) => {
  console.log("连接状态变化:", prevState, "->", curState, reason);
});
```

**平滑过渡要点**:

- 保持相同的连接状态监听逻辑
- 适配参数结构差异（位置参数 → 对象参数）
- 保持连接状态枚举的一致性

#### 4.4.2 断联处理平滑过渡

**Agora RTC断联处理**:

```typescript
client.on("connection-state-change", (curState, prevState) => {
  if (curState === "DISCONNECTED") {
    // 处理断联
    handleDisconnect();
  }
});
```

**阿里云RTC断联处理**:

```typescript
client.on("connection-state-change", (curState, prevState, reason) => {
  if (curState === "DISCONNECTED") {
    // 处理断联，增加reason参数
    handleDisconnect(reason);
  }
});
```

**平滑过渡要点**:

- 保持相同的断联检测逻辑
- 利用阿里云提供的reason参数进行更精确的断联处理
- 保持重连机制的一致性

#### 4.4.3 事件监听平滑过渡

**Agora RTC事件监听**:

```typescript
// 用户事件
client.on("user-joined", (user) => {
  console.log("用户加入:", user.uid);
});

client.on("user-left", (user) => {
  console.log("用户离开:", user.uid);
});

// 轨道事件
client.on("user-published", async (user, mediaType) => {
  await client.subscribe(user, mediaType);
});

client.on("user-unpublished", async (user, mediaType) => {
  await client.unsubscribe(user, mediaType);
});
```

**阿里云RTC事件监听**:

```typescript
// 用户事件
client.on("user-joined", (user) => {
  console.log("用户加入:", user.userId);
});

client.on("user-left", (user) => {
  console.log("用户离开:", user.userId);
});

// 轨道事件
client.on("user-published", async (user, mediaType) => {
  await client.subscribe(user, mediaType);
});

client.on("user-unpublished", async (user, mediaType) => {
  await client.unsubscribe(user, mediaType);
});
```

**平滑过渡要点**:

- 保持相同的事件监听结构
- 适配用户标识差异（uid → userId）
- 保持轨道订阅/取消订阅逻辑的一致性

#### 4.4.4 消息推送平滑过渡

**Agora RTM消息推送**:

```typescript
// 发送消息
await rtm.publish(channel, JSON.stringify(msg), {
  customType: "PainTxt",
});

// 接收消息
rtm.addEventListener("message", (e) => {
  const { message, messageType } = e;
  if (messageType === "STRING") {
    const msg = JSON.parse(message as string);
    handleMessage(msg);
  }
});
```

**阿里云RTM消息推送**:

```typescript
// 发送消息
const encoder = new TextEncoder();
rtm.publish(sessionId, encoder.encode(JSON.stringify(msg)));

// 接收消息
rtm.on("message", (data) => {
  const { message, uid, sessionId, broadcast } = data;
  const decoder = new TextDecoder("utf-8");
  const msg = JSON.parse(decoder.decode(message));
  handleMessage(msg);
});
```

**平滑过渡要点**:

- 保持消息处理逻辑的一致性
- 适配消息格式差异（字符串 → Uint8Array）
- 保持消息分片和重组机制
- 利用阿里云的session管理功能

## 5. 迁移优先级

### 5.1 高优先级（必须迁移）

1. **后端 Token 生成服务** - 支持阿里云 RTC Token 生成
2. **前端 RTC 客户端** - 使用阿里云 RTC SDK
3. **前端 RTM 消息传递** - 找到阿里云对应的消息传递方案
4. **前端 Token 获取** - 支持指定 RTC 类型

### 5.2 中优先级（需要适配）

1. **配置管理** - 添加阿里云 RTC 配置项
2. **错误处理** - 适配阿里云 RTC 错误
3. **消息流处理** - 适配阿里云消息传递的流式处理

### 5.3 低优先级（可选优化）

1. **Worker 配置传递** - 传递 RTC 类型信息
2. **日志记录** - 添加 RTC 类型相关日志

## 5. 重新规划笔记结构

### 5.1 核心迁移文档

- `06_Token生成服务迁移细节.md` ✅ (已完成)
- `07_前端RTC客户端迁移细节.md` ✅ (已完成)
- `10_前端Token获取迁移细节.md` (需要创建)

### 5.2 配置管理文档

- `11_配置管理迁移细节.md` (需要创建)
- `12_错误处理迁移细节.md` (需要创建)

### 5.3 辅助迁移文档

- `13_Worker配置传递简化.md` (需要创建)

## 6. 关键发现

### 6.1 迁移复杂度重新评估

- **核心迁移**: 3 个主要组件
- **配置适配**: 2 个配置项

### 6.2 风险重新评估

- **高风险**: Token 生成服务迁移
- **中风险**: 前端 RTC 客户端迁移
- **低风险**: 配置管理和错误处理

### 6.3 时间重新评估

- **第一阶段**: Token 生成服务 (1 周)
- **第二阶段**: 前端 RTC 客户端 (2 周)
- **第三阶段**: 配置和优化 (1 周)

## 7. 下一步计划

1. **创建前端 Token 获取迁移文档**
2. **创建配置管理迁移文档**
3. **创建错误处理迁移文档**
4. **简化 Worker 配置传递文档**

## 8. 注意事项

1. **专注核心**: 不要过度关注 Worker 细节
2. **保持简单**: 每个文档专注于一个核心迁移点
3. **渐进实施**: 先完成核心功能，再优化细节
4. **向后兼容**: 保持现有 Agora RTC 功能不变
