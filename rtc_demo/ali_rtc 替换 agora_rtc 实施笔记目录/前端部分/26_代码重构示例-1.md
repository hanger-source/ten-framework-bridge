# 代码重构示例 - 1: 前端重构

## 重构前的 RTCManager

```typescript
// 重构前: ai_agents/playground/src/components/RTCManager.ts
import AgoraRTC, { IAgoraRTCClient } from "agora-rtc-sdk-ng";

export class RTCManager {
  private client: IAgoraRTCClient;
  private localAudioTrack?: IMicrophoneAudioTrack;
  private localVideoTrack?: ICameraVideoTrack;

  constructor() {
    this.client = AgoraRTC.createClient({
      mode: "rtc",
      codec: "vp8",
    });
  }

  async join(channel: string, token: string, uid: string): Promise<void> {
    await this.client.join(token, channel, uid);
  }

  async createAudioTrack(): Promise<IMicrophoneAudioTrack> {
    this.localAudioTrack = await AgoraRTC.createMicrophoneAudioTrack({
      encoderConfig: "music_standard",
      AEC: true,
      AGC: true,
      ANS: true,
    });
    return this.localAudioTrack;
  }

  async createVideoTrack(): Promise<ICameraVideoTrack> {
    this.localVideoTrack = await AgoraRTC.createCameraVideoTrack({
      encoderConfig: "1080p_1",
      facingMode: "user",
      optimizationMode: "detail",
    });
    return this.localVideoTrack;
  }
}
```

## 重构后的 RTCManager

```typescript
// 重构后: ai_agents/playground/src/components/RTCManager.ts
import { IRTCClient } from "../interfaces/IRTCClient";
import { RTCClientFactory } from "../factories/RTCClientFactory";

export class RTCManager {
  private client: IRTCClient;

  constructor(rtcType: string = "agora") {
    this.client = RTCClientFactory.create(rtcType);
  }

  async join(channel: string, token: string, uid: string): Promise<void> {
    await this.client.join(channel, token, uid);
  }

  async createAudioTrack(): Promise<IAudioTrack> {
    return await this.client.createAudioTrack();
  }

  async createVideoTrack(): Promise<IVideoTrack> {
    return await this.client.createVideoTrack();
  }

  async publish(): Promise<void> {
    await this.client.publish();
  }

  destroy(): void {
    this.client.destroy();
  }

  on(event: string, handler: Function): void {
    this.client.on(event, handler);
  }
}
```

## 重构前后的对比

### 主要变化

1. **依赖注入**: 通过构造函数传入 RTC 类型
2. **接口抽象**: 使用统一的 `IRTCClient` 接口
3. **工厂模式**: 使用 `RTCClientFactory` 创建客户端
4. **类型统一**: 使用统一的 `IAudioTrack` 和 `IVideoTrack` 接口

### 优势

- **可扩展性**: 支持动态切换 RTC 服务
- **可维护性**: 统一的接口定义

- **向后兼容**: 保持原有的 API 不变
